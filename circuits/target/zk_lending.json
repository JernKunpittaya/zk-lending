{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":7070352373403255709,"abi":{"parameters":[{"name":"new_note_hash","type":{"kind":"field"},"visibility":"private"},{"name":"new_will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"new_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"new_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"new_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"prev_note","type":{"kind":"struct","path":"MyNote","fields":[{"name":"lend_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"borrow_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"nullifier","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]},"visibility":"private"},{"name":"prev_hash","type":{"kind":"field"},"visibility":"public"},{"name":"prev_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"prev_hash_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"liquidated_array","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"Liquidated","fields":[{"name":"liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}}]}},"visibility":"public"},{"name":"lend_token_out","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"borrow_token_out","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"lend_token_in","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"borrow_token_in","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"use dep::std;\n\n// ==== Global config ==== (percentage-based)\nglobal LTV_THRESHOLD: u64 = 50; //\nglobal LEND_INTEREST_RATE: u64 = 3; // annual rate (3%)\nglobal BORROW_INTEREST_RATE: u64 = 10; // annual rate (10%)\nglobal ACCEPTABLE_PERCENT: u64 = 1;\n\n// Assume price is integer\nstruct Liquidated {\n    liq_price: u64, // in smallest unit as integer\n    timestamp: u64,\n}\n\nstruct MyNote {\n    lend_amt: u64, // in smallest unit (scaled, e.g., x10^4)\n    borrow_amt: u64, // in smallest unit (scaled, e.g., x10^4)\n    will_liq_price: u64, // in smallest unit as integer\n    timestamp: u64,\n    nullifier: Field,\n    nonce: Field,\n}\n\nfn simple_hash(left: Field, right: Field) -> Field {\n    std::hash::poseidon2::Poseidon2::hash([left, right], 2)\n}\n\nfn hash_my_note(my_note: MyNote) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(\n        [\n            my_note.lend_amt as Field,\n            my_note.borrow_amt as Field,\n            my_note.will_liq_price as Field,\n            my_note.timestamp as Field,\n            my_note.nullifier,\n            my_note.nonce,\n        ],\n        6,\n    )\n}\n\n// ====== CONSTRAINT ================\n// assert if LTV condition is satisfied\nfn assert_ltv(my_note: MyNote) {\n    assert(my_note.borrow_amt * 100 <= LTV_THRESHOLD * my_note.lend_amt * my_note.will_liq_price);\n}\n\nfn abs_diff(x: u64, y: u64) -> u64 {\n    if x >= y {\n        x - y\n    } else {\n        y - x\n    }\n}\n\n// Check if two values are within a percentage range\nfn is_within_percentage(x: u64, y: u64, percent: u64) -> u8 {\n    let diff = abs_diff(x, y) * 100;\n    let allowed_diff = percent * y;\n    if diff <= allowed_diff {\n        1\n    } else {\n        0\n    }\n}\n\n// Check if our will_liq_price is actually liquidated or not, accounting for lend & borrow interest\nfn is_myposition_liquidated(my_price: u64, liq_price: u64, my_time: u64, liq_time: u64) -> u8 {\n    if liq_time < my_time {\n        0\n    } else {\n        let one_year_seconds = 365 * 24 * 60 * 60;\n        let time_diff = liq_time - my_time;\n\n        let borrow_factor = one_year_seconds + BORROW_INTEREST_RATE * time_diff;\n        let lend_factor = one_year_seconds + LEND_INTEREST_RATE * time_diff;\n\n        let my_adjusted_price = borrow_factor * my_price;\n        let liq_adjusted_price = lend_factor * liq_price;\n\n        is_within_percentage(my_adjusted_price, liq_adjusted_price, ACCEPTABLE_PERCENT)\n    }\n}\n\nfn assert_update_amt(\n    prev_amt: u64,\n    prev_timestamp: u64,\n    curr_amt: u64,\n    curr_timestamp: u64,\n    interest_rate: u64,\n) {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = curr_timestamp - prev_timestamp;\n\n    let projected_amt = (one_year_seconds + interest_rate * time_diff) * prev_amt;\n    let actual_amt = one_year_seconds * curr_amt;\n\n    assert(is_within_percentage(projected_amt, actual_amt, ACCEPTABLE_PERCENT) == 1);\n}\n\n// check if my position is liquidated\nfn is_my_pos_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) -> u8 {\n    let mut is_liquidated: u8 = 0;\n\n    for i in 0..3 {\n        let check = is_myposition_liquidated(\n            my_note.will_liq_price,\n            liquidated_array[i].liq_price,\n            my_note.timestamp,\n            liquidated_array[i].timestamp,\n        );\n        is_liquidated += check;\n    }\n    if is_liquidated > 0 {\n        1\n    } else {\n        0\n    }\n}\n\n// assert that my position not liquidated\nfn assert_non_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) {\n    assert(is_my_pos_liquidated(my_note, liquidated_array) == 0);\n}\n\n// assert that my position gets liquidated\nfn assert_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) {\n    assert(is_my_pos_liquidated(my_note, liquidated_array) == 1);\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        simple_hash(leaf, another_leaf)\n    } else {\n        simple_hash(another_leaf, leaf)\n    }\n}\n\nfn assert_inclusion_proof(leaf: Field, index: u32, hash_path: [Field; 3], root: Field) {\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..3 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n\n    assert(calculated_hash == root);\n}\n\n// ============ zk-lending OPERATION CONSTRAINT =============\n\n// if no borrow when initiating note, set borrow_amt = 0, and will_liq_price = 0\nfn init_note(\n    lend_amt: u64,\n    borrow_amt: u64,\n    will_liq_price: u64,\n    timestamp: u64,\n    nullifier: Field,\n    nonce: Field,\n) -> MyNote {\n    let my_note: MyNote =\n        MyNote { lend_amt, borrow_amt, will_liq_price, timestamp, nullifier, nonce };\n    assert_ltv(my_note);\n    my_note\n}\n\nfn borrow(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    additional_borrow_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    // assert updated lending amount\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    // assert updated borrowing amount (before borrowing more)\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt - additional_borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn repay(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    repay_borrow_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    // assert updated lending amount\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    assert(\n        repay_borrow_amt\n            <= update_amt(\n                prev_note.borrow_amt,\n                prev_note.timestamp,\n                new_note.timestamp,\n                BORROW_INTEREST_RATE,\n            ),\n    );\n\n    // assert updated borrowing amount (before borrowing more)\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt + repay_borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn lend(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    additional_deposit_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    // assert updated lending amount (before lending/depositing more)\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt - additional_deposit_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    // assert updated borrowing amount\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn withdraw(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    withdraw_lend_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    assert(\n        withdraw_lend_amt\n            <= update_amt(\n                prev_note.lend_amt,\n                prev_note.timestamp,\n                new_note.timestamp,\n                LEND_INTEREST_RATE,\n            ),\n    );\n\n    // assert updated lending amount (before lending/depositing more)\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt + withdraw_lend_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    // assert updated borrowing amount\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\n// =============== HELPER FUNCTIONS ========================\n\nfn construct_merkle_tree(leaf_array: [Field; 8]) -> [Field; 7] {\n    let mut lv1_nodes: [Field; 4] = [0; 4];\n    for i in 0..4 {\n        lv1_nodes[i] = simple_hash(leaf_array[2 * i], leaf_array[2 * i + 1]);\n    }\n    let mut lv2_nodes: [Field; 2] = [0; 2];\n    for i in 0..2 {\n        lv2_nodes[i] = simple_hash(lv1_nodes[2 * i], lv1_nodes[2 * i + 1]);\n    }\n    let root = simple_hash(lv2_nodes[0], lv2_nodes[1]);\n    [lv1_nodes[0], lv1_nodes[1], lv1_nodes[2], lv1_nodes[3], lv2_nodes[0], lv2_nodes[1], root]\n}\n\nfn update_amt(prev_amt: u64, prev_timestamp: u64, curr_timestamp: u64, interest_rate: u64) -> u64 {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = curr_timestamp - prev_timestamp;\n\n    (one_year_seconds + interest_rate * time_diff) * prev_amt / one_year_seconds\n}\n\nfn update_lend_amt_new_liq_price(will_liq_price: u64, borrow_amt: u64) -> u64 {\n    borrow_amt * 100 / (will_liq_price * LTV_THRESHOLD) + 1\n}\n\nfn update_borrow_amt_new_liq_price(will_liq_price: u64, lend_amt: u64) -> u64 {\n    will_liq_price * LTV_THRESHOLD * lend_amt / 100\n}\n\nfn global_will_liq_price(initial_will_liq_price: u64, timestamp: u64) -> u64 {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = timestamp - 0;\n\n    let borrow_factor = one_year_seconds + BORROW_INTEREST_RATE * time_diff;\n    let lend_factor = one_year_seconds + LEND_INTEREST_RATE * time_diff;\n\n    borrow_factor * initial_will_liq_price / lend_factor\n}\n\n// Zringotts Circuit - all in one zk banking operation\n// 1. init note - if old is empty init note with no check\n// 2. if liquidated, force sell all assets and credit it as borrow asset\n// 3. lend, borrow, repay, withdraw - attempt to update the note and check aginst constraints\nfn main(\n    new_note_hash: Field,\n    new_will_liq_price: pub u64,\n    new_timestamp: pub u64,\n    new_nullifier: Field,\n    new_nonce: Field,\n    prev_note: MyNote,\n    prev_hash: pub Field,\n    prev_index: u32,\n    prev_hash_path: pub [Field; 3],\n    root: pub Field,\n    liquidated_array: pub [Liquidated; 3],\n    lend_token_out: pub u64,\n    borrow_token_out: pub u64,\n    lend_token_in: pub u64,\n    borrow_token_in: pub u64,\n) {\n    // return the new note hash\n\n    // assert that token in and out are mutually exclusive\n    assert(lend_token_in * lend_token_out == 0);\n    assert(borrow_token_in * borrow_token_out == 0);\n\n    // if old is empty no inclusion proof needed.\n    // note: lend_amt, borrow_amt, will_liq_price = 0 mean empty note\n    if (prev_note.lend_amt + prev_note.borrow_amt + prev_note.will_liq_price) > 0 {\n        // validate the old note\n        assert(hash_my_note(prev_note) == prev_hash);\n        assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    }\n\n    // if the old note is liquidated, settle the note\n    if is_my_pos_liquidated(prev_note, liquidated_array) == 1 {\n        // calculate asset left after liquidation. interest is forfeited in this case.\n        // give asset back to the user and reset the note\n        assert_liquidated(prev_note, liquidated_array);\n        let lend_asset_left_eqv = prev_note.lend_amt * prev_note.will_liq_price;\n        let borrow_amt = update_amt(\n            prev_note.borrow_amt,\n            prev_note.timestamp,\n            new_timestamp,\n            BORROW_INTEREST_RATE,\n        );\n        let borrow_asset_left_eqv = lend_asset_left_eqv - borrow_amt;\n        assert(borrow_token_out <= borrow_asset_left_eqv);\n        assert(borrow_token_in == 0);\n        assert(lend_token_out == 0);\n        assert(lend_token_in == 0);\n        let my_note = MyNote {\n            lend_amt: 0,\n            borrow_amt: 0,\n            will_liq_price: 0,\n            timestamp: new_timestamp,\n            nullifier: new_nullifier,\n            nonce: new_nonce,\n        };\n        assert(new_note_hash == hash_my_note(my_note));\n    } else {\n        // assert that the old note is not liquidated\n        assert_non_liquidated(prev_note, liquidated_array);\n\n        let new_lend_amt = update_amt(\n            prev_note.lend_amt,\n            prev_note.timestamp,\n            new_timestamp,\n            LEND_INTEREST_RATE,\n        )\n            + lend_token_in\n            - lend_token_out;\n        let new_borrow_amt = update_amt(\n            prev_note.borrow_amt,\n            prev_note.timestamp,\n            new_timestamp,\n            BORROW_INTEREST_RATE,\n        )\n            + borrow_token_in\n            - borrow_token_out;\n        let my_note = MyNote {\n            lend_amt: new_lend_amt,\n            borrow_amt: new_borrow_amt,\n            will_liq_price: new_will_liq_price,\n            timestamp: new_timestamp,\n            nullifier: new_nullifier,\n            nonce: new_nonce,\n        };\n        assert_ltv(my_note);\n        // assert that the new note is not liquidated\n        assert_non_liquidated(my_note, liquidated_array);\n        assert(new_note_hash == hash_my_note(my_note));\n    }\n    // return 0 as placeholder\n}\n\n#[test]\nfn test_main() {\n    // Time = 0, current ETH price = 3000,\n    // there exists buckets at liquidation price 2800, 2600, 2400, 2200\n\n    let zero_leaf = 0 as Field;\n    let mut merkle_leaves: [Field; 8] = (\n        [\n            1234 as Field,\n            542 as Field,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n        ]\n    );\n    let mut liquidated_array: [Liquidated; 3] = [\n        Liquidated { liq_price: 0, timestamp: 0 },\n        Liquidated { liq_price: 0, timestamp: 0 },\n        Liquidated { liq_price: 0, timestamp: 0 },\n    ];\n    // a, b deposit and borrow right away\n    let a_init_lend_amt = 50000; // already scale by (10^4)\n    let a_init_will_liq_price = 2800;\n    let a_init_borrow_amt = update_borrow_amt_new_liq_price(a_init_will_liq_price, a_init_lend_amt);\n    let a_init_note = init_note(\n        a_init_lend_amt,\n        a_init_borrow_amt,\n        a_init_will_liq_price,\n        0,\n        112 as Field,\n        13 as Field,\n    );\n\n    let b_init_lend_amt = 20000; // already scale by (10^4)\n    let b_init_will_liq_price = 2600;\n    let b_init_borrow_amt = update_borrow_amt_new_liq_price(b_init_will_liq_price, b_init_lend_amt);\n    let b_init_note = init_note(\n        b_init_lend_amt,\n        b_init_borrow_amt,\n        b_init_will_liq_price,\n        0,\n        132 as Field,\n        156 as Field,\n    );\n\n    let a_init_note_hash = hash_my_note(a_init_note);\n    let a_init_note_index = 2;\n    merkle_leaves[a_init_note_index] = a_init_note_hash;\n    let b_init_note_hash = hash_my_note(b_init_note);\n    let b_init_note_index = 3;\n    merkle_leaves[b_init_note_index] = b_init_note_hash;\n\n    // T = 4 hrs, liquidate 2800 ish, then bounce back 2900\n    let timestamp_4_hrs = 4 * 60 * 60;\n    liquidated_array[0] = Liquidated {\n        liq_price: global_will_liq_price(2800, timestamp_4_hrs),\n        timestamp: timestamp_4_hrs,\n    };\n\n    // T = 12 hrs, liquidate 2800 ish again (since someone initiate position in this bucket)\n    let timestamp_12_hrs = 12 * 60 * 60;\n    liquidated_array[1] = Liquidated {\n        liq_price: global_will_liq_price(2800, timestamp_12_hrs),\n        timestamp: timestamp_12_hrs,\n    };\n\n    // a's position is gone\n    assert_liquidated(a_init_note, liquidated_array);\n\n    // T = 32 hrs\n    // b lend more, making will_liq_price drop to around 2200\n    let timestamp_32_hrs = 32 * 60 * 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_init_note_hash_path = [merkle_leaves[2], merkle_tree[0], merkle_tree[5]];\n    let merkle_root = merkle_tree[6];\n\n    let b_2200_will_liq_price = global_will_liq_price(2200, timestamp_32_hrs);\n    let b_2200_borrow_amt = update_amt(\n        b_init_note.borrow_amt,\n        b_init_note.timestamp,\n        timestamp_32_hrs,\n        BORROW_INTEREST_RATE,\n    );\n\n    let b_2200_lend_amt = update_lend_amt_new_liq_price(b_2200_will_liq_price, b_2200_borrow_amt);\n    let b_updated_lend_amt = update_amt(\n        b_init_note.lend_amt,\n        b_init_note.timestamp,\n        timestamp_32_hrs,\n        LEND_INTEREST_RATE,\n    );\n    let b_additional_lend_amt = b_2200_lend_amt - b_updated_lend_amt;\n\n    let b_2200_note = MyNote {\n        lend_amt: b_2200_lend_amt,\n        borrow_amt: b_2200_borrow_amt,\n        will_liq_price: b_2200_will_liq_price,\n        timestamp: timestamp_32_hrs,\n        nullifier: 999 as Field,\n        nonce: 888 as Field,\n    };\n\n    lend(\n        b_init_note,\n        b_init_note_hash,\n        b_init_note_index,\n        b_init_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_2200_note,\n        b_additional_lend_amt,\n    );\n\n    let b_2200_note_hash = hash_my_note(b_2200_note);\n    let b_2200_note_index = 4;\n    merkle_leaves[b_2200_note_index] = b_2200_note_hash;\n\n    // T = 32 hrs\n    // b borrow more, making will_liq_price rise to around 2400\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_2200_note_hash_path = [zero_leaf, merkle_tree[3], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    let b_2400_will_liq_price = global_will_liq_price(2400, timestamp_32_hrs);\n    let b_2400_lend_amt = update_amt(\n        b_2200_note.lend_amt,\n        b_2200_note.timestamp,\n        timestamp_32_hrs,\n        LEND_INTEREST_RATE,\n    );\n\n    let b_2400_borrow_amt = update_borrow_amt_new_liq_price(b_2400_will_liq_price, b_2400_lend_amt);\n    let b_updated_borrow_amt = update_amt(\n        b_2200_note.borrow_amt,\n        b_2200_note.timestamp,\n        timestamp_32_hrs,\n        BORROW_INTEREST_RATE,\n    );\n    let b_additional_borrow_amt = b_2400_borrow_amt - b_updated_borrow_amt;\n\n    let b_2400_note = MyNote {\n        lend_amt: b_2400_lend_amt,\n        borrow_amt: b_2400_borrow_amt,\n        will_liq_price: b_2400_will_liq_price,\n        timestamp: timestamp_32_hrs,\n        nullifier: 1890 as Field,\n        nonce: 97 as Field,\n    };\n\n    borrow(\n        b_2200_note,\n        b_2200_note_hash,\n        b_2200_note_index,\n        b_2200_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_2400_note,\n        b_additional_borrow_amt,\n    );\n\n    let b_2400_note_hash = hash_my_note(b_2400_note);\n    let b_2400_note_index = 5;\n    merkle_leaves[b_2400_note_index] = b_2400_note_hash;\n\n    // T = 72 hrs, liquidate 2600 ish..\n    let timestamp_72_hrs = 72 * 60 * 60;\n    liquidated_array[2] = Liquidated {\n        liq_price: global_will_liq_price(2600, timestamp_72_hrs),\n        timestamp: timestamp_72_hrs,\n    };\n\n    // T = 96 hrs, b repays all his debt\n    let timestamp_96_hrs = 96 * 60 * 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_2400_note_hash_path = [merkle_leaves[4], merkle_tree[3], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    // repay all debt\n    let b_0_will_liq_price = 0;\n    let b_0_lend_amt = update_amt(\n        b_2400_note.lend_amt,\n        b_2400_note.timestamp,\n        timestamp_96_hrs,\n        LEND_INTEREST_RATE,\n    );\n\n    let b_0_borrow_amt = 0;\n    let b_updated_borrow_amt = update_amt(\n        b_2400_note.borrow_amt,\n        b_2400_note.timestamp,\n        timestamp_96_hrs,\n        BORROW_INTEREST_RATE,\n    );\n    let b_repay_borrow_amt = b_updated_borrow_amt - b_0_borrow_amt;\n\n    let b_0_note = MyNote {\n        lend_amt: b_0_lend_amt,\n        borrow_amt: b_0_borrow_amt,\n        will_liq_price: b_0_will_liq_price,\n        timestamp: timestamp_96_hrs,\n        nullifier: 2 as Field,\n        nonce: 932494 as Field,\n    };\n\n    repay(\n        b_2400_note,\n        b_2400_note_hash,\n        b_2400_note_index,\n        b_2400_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_0_note,\n        b_repay_borrow_amt,\n    );\n\n    let b_0_note_hash = hash_my_note(b_0_note);\n    let b_0_note_index = 6;\n    merkle_leaves[b_0_note_index] = b_0_note_hash;\n\n    // T = 120 hrs, b withdraw some money\n    let timestamp_120_hrs = 120 * 60 * 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_0_note_hash_path = [zero_leaf, merkle_tree[2], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    let b_updated_lend_amt = update_amt(\n        b_0_note.lend_amt,\n        b_0_note.timestamp,\n        timestamp_120_hrs,\n        LEND_INTEREST_RATE,\n    );\n    let b_final_lend_amt = 20000;\n    let b_final_borrow_amt = 0;\n    let b_withdraw_lend_amt = b_updated_lend_amt - b_final_lend_amt;\n\n    let b_final_note = MyNote {\n        lend_amt: b_final_lend_amt,\n        borrow_amt: b_final_borrow_amt,\n        will_liq_price: 0,\n        timestamp: timestamp_120_hrs,\n        nullifier: 223 as Field,\n        nonce: 12309 as Field,\n    };\n\n    withdraw(\n        b_0_note,\n        b_0_note_hash,\n        b_0_note_index,\n        b_0_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_final_note,\n        b_withdraw_lend_amt,\n    );\n}\n\n#[test]\nfn test_inclusion_proof() {\n    let a = 1 as Field;\n    let b = 2 as Field;\n    let c = 3 as Field;\n    let d = 4 as Field;\n    let zero = 0 as Field;\n\n    let merkle_leaves = [a, b, c, d, zero, zero, zero, zero];\n    let merkle = construct_merkle_tree(merkle_leaves);\n\n    let leaf = c;\n    let index = 2;\n    let hash_path = [d, merkle[0], merkle[5]];\n    let root = merkle[6];\n\n    assert_inclusion_proof(leaf, index, hash_path, root);\n}\n\n#[test]\nfn test_ltv() {\n    let my_note = MyNote {\n        lend_amt: 5,\n        borrow_amt: 10,\n        will_liq_price: 4,\n        timestamp: 1000,\n        nullifier: 111 as Field,\n        nonce: 222 as Field,\n    };\n    assert_ltv(my_note);\n}\n\n#[test]\nfn test_liquidation_check() {\n    let my_note = MyNote {\n        lend_amt: 1,\n        borrow_amt: 500,\n        will_liq_price: 1000,\n        timestamp: 1000,\n        nullifier: 111 as Field,\n        nonce: 222 as Field,\n    };\n\n    let liquidated_array = [\n        Liquidated { liq_price: 1100, timestamp: 1005 },\n        Liquidated { liq_price: 1200, timestamp: 1010 },\n        Liquidated { liq_price: 1100, timestamp: 1200 },\n    ];\n    assert_ltv(my_note);\n    assert_non_liquidated(my_note, liquidated_array);\n}\n","path":"/Users/yoisha/Development/crypto/zk-lending/circuits/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}