{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":15303100666362349043,"abi":{"parameters":[{"name":"new_will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"new_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"new_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"new_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"prev_note","type":{"kind":"struct","path":"MyNote","fields":[{"name":"lend_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"borrow_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"nullifier","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]},"visibility":"private"},{"name":"prev_hash","type":{"kind":"field"},"visibility":"private"},{"name":"prev_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"prev_hash_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"private"},{"name":"liquidated_array","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"Liquidated","fields":[{"name":"liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}}]}},"visibility":"private"},{"name":"withdraw_lend_amt","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"lend_token_out","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrow_token_out","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"lend_token_in","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrow_token_in","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"use dep::std;\n\n// ==== Global config ==== (percentage-based)\nglobal LTV_THRESHOLD: u64 = 50; //\nglobal LEND_INTEREST_RATE: u64 = 3; // annual rate\nglobal BORROW_INTEREST_RATE: u64 = 10; // annual rate\nglobal ACCEPTABLE_PERCENT:u64 = 1;\n\n// Assume price is integer\nstruct Liquidated{\n    liq_price: u64, // in smallest unit as integer\n    timestamp: u64\n}\n\nstruct MyNote{\n    lend_amt: u64,   // in smallest unit (scaled, e.g., x10^4)\n    borrow_amt: u64, // in smallest unit (scaled, e.g., x10^4)\n    will_liq_price: u64, // in smallest unit as integer\n    timestamp: u64,\n    nullifier: Field,\n    nonce: Field\n}\n\nfn simple_hash(left: Field, right: Field) -> Field{\n    std::hash::pedersen_hash([left, right])\n}\n\nfn hash_my_note(my_note: MyNote) -> Field{\n    std::hash::pedersen_hash([\n        my_note.lend_amt as Field, \n        my_note.borrow_amt as Field, \n        my_note.will_liq_price as Field, \n        my_note.timestamp as Field, \n        my_note.nullifier, \n        my_note.nonce\n    ])\n}\n\n// ====== CONSTRAINT ================\n// assert if LTV condition is satisfied\nfn assert_ltv(my_note: MyNote){\n    assert(my_note.borrow_amt * 100 <= LTV_THRESHOLD * my_note.lend_amt * my_note.will_liq_price);\n}\n\n\nfn abs_diff(x:u64, y:u64) -> u64 {\n    if x >=y { x-y } else { y-x }\n}\n\n// Check if two values are within a percentage range\nfn is_within_percentage(x: u64, y: u64, percent: u64) -> u8 {\n    let diff = abs_diff(x, y) * 100;\n    let allowed_diff = percent * y;\n    if diff <= allowed_diff { 1 } else { 0 }\n}\n\n\n// Check if our will_liq_price is actually liquidated or not, accounting for lend & borrow interest\nfn is_myposition_liquidated( my_price: u64, liq_price: u64, my_time: u64, liq_time: u64) -> u8 {\n    if liq_time < my_time{\n        0\n    } else{\n        let one_year_seconds = 365 * 24 * 60 * 60;\n        let time_diff = liq_time - my_time;\n\n        let borrow_factor = one_year_seconds + BORROW_INTEREST_RATE * time_diff;\n        let lend_factor = one_year_seconds + LEND_INTEREST_RATE * time_diff;\n\n        let my_adjusted_price = borrow_factor * my_price;\n        let liq_adjusted_price = lend_factor * liq_price;\n\n        is_within_percentage(my_adjusted_price, liq_adjusted_price, ACCEPTABLE_PERCENT)\n    }\n}\n\nfn assert_update_amt(prev_amt: u64, prev_timestamp: u64, curr_amt: u64, curr_timestamp: u64, interest_rate: u64){\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = curr_timestamp - prev_timestamp;\n\n    let projected_amt = (one_year_seconds + interest_rate * time_diff) * prev_amt;\n    let actual_amt = one_year_seconds * curr_amt;\n\n    assert(is_within_percentage(projected_amt, actual_amt, ACCEPTABLE_PERCENT) == 1);\n}\n\n// check if my position is liquidated \nfn is_my_pos_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) -> u8 {\n    let mut is_liquidated: u8 = 0;\n\n    for i in 0..3 {\n        let check = is_myposition_liquidated(\n            my_note.will_liq_price,\n            liquidated_array[i].liq_price,\n            my_note.timestamp,\n            liquidated_array[i].timestamp,\n        );\n        is_liquidated += check;\n    }\n    if is_liquidated >0 { 1 } else { 0 }\n}\n\n// assert that my position not liquidated\nfn assert_non_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]){\n    assert(is_my_pos_liquidated(my_note, liquidated_array)==0);\n}\n\n// assert that my position gets liquidated\nfn assert_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]){\n    assert(is_my_pos_liquidated(my_note, liquidated_array)==1);\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        simple_hash(leaf, another_leaf)\n    } else {\n        simple_hash(another_leaf, leaf)\n    }\n}\n\nfn assert_inclusion_proof(leaf: Field, index: u32, hash_path:[Field;3], root:Field){\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..3 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n\n    assert(calculated_hash == root);\n}\n\n\n// ============ zk-lending OPERATION CONSTRAINT =============\n\n// if no borrow when initiating note, set borrow_amt = 0, and will_liq_price = 0\nfn init_note(lend_amt: u64, borrow_amt: u64, will_liq_price: u64, timestamp: u64, nullifier: Field, nonce: Field) -> MyNote{\n    let my_note: MyNote = MyNote{\n        lend_amt,\n        borrow_amt,\n        will_liq_price, \n        timestamp,\n        nullifier,\n        nonce\n    };\n    assert_ltv(my_note);\n    my_note\n}\n\nfn borrow(prev_note: MyNote, prev_hash: Field, prev_index: u32, prev_hash_path: [Field; 3], root: Field, liquidated_array: [Liquidated; 3], new_note:MyNote, additional_borrow_amt:u64) -> Field{\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n    \n    // assert updated lending amount\n    assert_update_amt(prev_note.lend_amt, prev_note.timestamp, new_note.lend_amt, new_note.timestamp, LEND_INTEREST_RATE);\n\n    // assert updated borrowing amount (before borrowing more)\n    assert_update_amt(prev_note.borrow_amt, prev_note.timestamp, new_note.borrow_amt - additional_borrow_amt, new_note.timestamp, BORROW_INTEREST_RATE);\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn repay(prev_note: MyNote, prev_hash: Field, prev_index: u32, prev_hash_path: [Field; 3], root: Field, liquidated_array: [Liquidated; 3], new_note:MyNote, repay_borrow_amt:u64) -> Field{\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n    \n    // assert updated lending amount\n    assert_update_amt(prev_note.lend_amt, prev_note.timestamp, new_note.lend_amt, new_note.timestamp, LEND_INTEREST_RATE);\n\n    assert(repay_borrow_amt <= update_amt(prev_note.borrow_amt, prev_note.timestamp, new_note.timestamp, BORROW_INTEREST_RATE));\n    \n    // assert updated borrowing amount (before borrowing more)\n    assert_update_amt(prev_note.borrow_amt, prev_note.timestamp, new_note.borrow_amt + repay_borrow_amt, new_note.timestamp, BORROW_INTEREST_RATE);\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\n\nfn lend(prev_note: MyNote, prev_hash: Field, prev_index: u32, prev_hash_path: [Field; 3], root: Field, liquidated_array: [Liquidated; 3], new_note:MyNote, additional_deposit_amt:u64) -> Field{\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n    \n    // assert updated lending amount (before lending/depositing more)\n    assert_update_amt(prev_note.lend_amt, prev_note.timestamp, new_note.lend_amt - additional_deposit_amt, new_note.timestamp, LEND_INTEREST_RATE);\n\n    // assert updated borrowing amount \n    assert_update_amt(prev_note.borrow_amt, prev_note.timestamp, new_note.borrow_amt, new_note.timestamp, BORROW_INTEREST_RATE);\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\n\nfn withdraw(prev_note: MyNote, prev_hash: Field, prev_index: u32, prev_hash_path: [Field; 3], root: Field, liquidated_array: [Liquidated; 3], new_note:MyNote, withdraw_lend_amt:u64) -> Field{\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n    \n    assert(withdraw_lend_amt <= update_amt(prev_note.lend_amt, prev_note.timestamp, new_note.timestamp, LEND_INTEREST_RATE));\n    \n    // assert updated lending amount (before lending/depositing more)\n    assert_update_amt(prev_note.lend_amt, prev_note.timestamp, new_note.lend_amt + withdraw_lend_amt, new_note.timestamp, LEND_INTEREST_RATE);\n\n    // assert updated borrowing amount \n    assert_update_amt(prev_note.borrow_amt, prev_note.timestamp, new_note.borrow_amt, new_note.timestamp, BORROW_INTEREST_RATE);\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\n// =============== HELPER FUNCTIONS ========================\n\nfn construct_merkle_tree(leaf_array:[Field;8]) -> [Field;7]{\n    let mut lv1_nodes: [Field;4] = [0;4];\n    for i in 0..4 {\n        lv1_nodes[i] = simple_hash(leaf_array[2*i], leaf_array[2*i+1]);\n    }\n    let mut lv2_nodes: [Field;2] = [0;2];\n    for i in 0..2 {\n        lv2_nodes[i] = simple_hash(lv1_nodes[2*i], lv1_nodes[2*i+1]);\n    }\n    let root = simple_hash(lv2_nodes[0], lv2_nodes[1]);\n    [lv1_nodes[0], lv1_nodes[1], lv1_nodes[2], lv1_nodes[3], lv2_nodes[0], lv2_nodes[1], root]\n\n}\n\nfn update_amt(prev_amt: u64, prev_timestamp: u64, curr_timestamp: u64, interest_rate: u64)-> u64{\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = curr_timestamp - prev_timestamp;\n\n    (one_year_seconds + interest_rate * time_diff) * prev_amt/one_year_seconds\n    \n}\n\nfn update_lend_amt_new_liq_price(will_liq_price: u64, borrow_amt: u64) -> u64 {\n    borrow_amt*100/(will_liq_price*LTV_THRESHOLD)+1\n}\n\nfn update_borrow_amt_new_liq_price(will_liq_price: u64, lend_amt: u64) -> u64 {\n    will_liq_price*LTV_THRESHOLD*lend_amt/100\n}\n\nfn global_will_liq_price(initial_will_liq_price: u64, timestamp: u64) -> u64 {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = timestamp - 0;\n\n    let borrow_factor = one_year_seconds + BORROW_INTEREST_RATE * time_diff;\n    let lend_factor = one_year_seconds + LEND_INTEREST_RATE * time_diff;\n\n    borrow_factor * initial_will_liq_price/ lend_factor\n}\n\nfn main(\n    new_will_liq_price: u64, new_timestamp: u64, new_nullifier: Field, new_nonce: Field,\n    prev_note: MyNote, prev_hash: Field, prev_index: u32, prev_hash_path: [Field; 3], root: Field, \n    liquidated_array: [Liquidated; 3], withdraw_lend_amt:u64, lend_token_out: u64, borrow_token_out: u64,lend_token_in: u64, borrow_token_in: u64,\n) -> pub Field { // return the new note hash\n\n    // assert that token in and out are mutually exclusive\n    assert(lend_token_in * lend_token_out == 0);\n    assert(borrow_token_in * borrow_token_out == 0); \n\n    // old is empty init note with no check -> return\n    if (prev_note.lend_amt == 0) & (prev_note.borrow_amt == 0) & (prev_note.will_liq_price == 0){\n        let my_note = init_note(lend_token_in, borrow_token_out, new_will_liq_price, new_timestamp, new_nullifier, new_nonce);\n        assert_ltv(my_note);\n        hash_my_note(my_note);\n    } else { // validate the old note\n        assert(hash_my_note(prev_note) == prev_hash);\n        assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    }\n\n    // if the old note is liquidated, settle the note\n    if is_my_pos_liquidated(prev_note, liquidated_array) == 1 {\n        // calculate asset left after liquidation. interest is forfeited in this case. \n        // give asset back to the user and reset the note\n        assert_liquidated(prev_note, liquidated_array);\n        let lend_asset_left_eqv = prev_note.lend_amt * prev_note.will_liq_price;\n        let borrow_amt = update_amt(prev_note.borrow_amt, prev_note.timestamp, new_timestamp, BORROW_INTEREST_RATE);\n        let borrow_asset_left_eqv = lend_asset_left_eqv - borrow_amt;\n        assert(borrow_token_out <= borrow_asset_left_eqv);\n        assert(borrow_token_in == 0);\n        assert(lend_token_out == 0);\n        assert(lend_token_in == 0);\n        let my_note = MyNote {\n            lend_amt: 0,\n            borrow_amt: 0,\n            will_liq_price: 0,\n            timestamp:new_timestamp,\n            nullifier:new_nullifier,\n            nonce:new_nonce\n        };\n        hash_my_note(my_note);\n    } else {\n        // assert that the old note is not liquidated\n        assert_non_liquidated(prev_note, liquidated_array);\n\n        let new_lend_amt = update_amt(prev_note.lend_amt, prev_note.timestamp, new_timestamp, LEND_INTEREST_RATE) + lend_token_in - lend_token_out;\n        let new_borrow_amt = update_amt(prev_note.borrow_amt, prev_note.timestamp, new_timestamp, BORROW_INTEREST_RATE) + borrow_token_in - borrow_token_out; \n        let my_note = MyNote {\n            lend_amt: new_lend_amt,\n            borrow_amt: new_borrow_amt,\n            will_liq_price: new_will_liq_price,\n            timestamp: new_timestamp,\n            nullifier:new_nullifier,\n            nonce:new_nonce,\n        };\n        assert_ltv(my_note);\n        // assert that the new note is not liquidated\n        assert_non_liquidated(my_note, liquidated_array);\n        hash_my_note(my_note);\n    }\n    hash_my_note(MyNote{\n        lend_amt: 0,\n        borrow_amt: 0,\n        will_liq_price: 0,\n        timestamp: new_timestamp,\n        nullifier: new_nullifier,\n        nonce: new_nonce\n    })\n    // return 0 as placeholder\n}\n\n\n#[test]\nfn test_main() {\n    // Time = 0, current ETH price = 3000,\n    // there exists buckets at liquidation price 2800, 2600, 2400, 2200\n\n    let zero_leaf = 0 as Field;\n    let mut merkle_leaves: [Field;8] = ([1234 as Field, 542 as Field, zero_leaf, zero_leaf , zero_leaf, zero_leaf, zero_leaf, zero_leaf ]);\n    let mut liquidated_array: [Liquidated;3] = [Liquidated{ liq_price: 0, timestamp: 0}, Liquidated{ liq_price: 0, timestamp: 0}, Liquidated{ liq_price: 0, timestamp: 0}];\n    // a, b deposit and borrow right away\n    let a_init_lend_amt = 50000; // already scale by (10^4)\n    let a_init_will_liq_price = 2800;\n    let a_init_borrow_amt = update_borrow_amt_new_liq_price(a_init_will_liq_price, a_init_lend_amt); \n    let a_init_note = init_note(a_init_lend_amt, a_init_borrow_amt, a_init_will_liq_price, 0, 112 as Field, 13 as Field);\n    \n    let b_init_lend_amt = 20000; // already scale by (10^4)\n    let b_init_will_liq_price = 2600;\n    let b_init_borrow_amt = update_borrow_amt_new_liq_price(b_init_will_liq_price, b_init_lend_amt); \n    let b_init_note = init_note(b_init_lend_amt, b_init_borrow_amt, b_init_will_liq_price, 0, 132 as Field, 156 as Field);\n    \n\n    let a_init_note_hash = hash_my_note(a_init_note);\n    let a_init_note_index = 2;\n    merkle_leaves[a_init_note_index] = a_init_note_hash;\n    let b_init_note_hash = hash_my_note(b_init_note);\n    let b_init_note_index = 3;\n    merkle_leaves[b_init_note_index] = b_init_note_hash;\n\n    // T = 4 hrs, liquidate 2800 ish, then bounce back 2900 \n    let timestamp_4_hrs = 4* 60* 60;\n    liquidated_array[0] = Liquidated{liq_price: global_will_liq_price(2800, timestamp_4_hrs), timestamp: timestamp_4_hrs};\n    \n    // T = 12 hrs, liquidate 2800 ish again (since someone initiate position in this bucket)\n    let timestamp_12_hrs = 12* 60* 60;\n    liquidated_array[1] = Liquidated{liq_price: global_will_liq_price(2800, timestamp_12_hrs), timestamp:timestamp_12_hrs};\n\n    // a's position is gone\n    assert_liquidated(a_init_note, liquidated_array);\n\n    // T = 32 hrs\n    // b lend more, making will_liq_price drop to around 2200\n    let timestamp_32_hrs = 32*60*60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_init_note_hash_path = [merkle_leaves[2], merkle_tree[0], merkle_tree[5]];\n    let merkle_root = merkle_tree[6];\n\n    let b_2200_will_liq_price =  global_will_liq_price(2200, timestamp_32_hrs);\n    let b_2200_borrow_amt = update_amt(b_init_note.borrow_amt, b_init_note.timestamp, timestamp_32_hrs, BORROW_INTEREST_RATE);\n    \n    let b_2200_lend_amt = update_lend_amt_new_liq_price(b_2200_will_liq_price, b_2200_borrow_amt);\n    let b_updated_lend_amt = update_amt(b_init_note.lend_amt, b_init_note.timestamp, timestamp_32_hrs, LEND_INTEREST_RATE );\n    let b_additional_lend_amt = b_2200_lend_amt - b_updated_lend_amt;\n    \n\n    let b_2200_note = MyNote {\n        lend_amt: b_2200_lend_amt,\n        borrow_amt: b_2200_borrow_amt,\n        will_liq_price: b_2200_will_liq_price,\n        timestamp: timestamp_32_hrs,\n        nullifier: 999 as Field,\n        nonce: 888 as Field,\n    };\n\n    lend(\n        b_init_note,\n        b_init_note_hash,\n        b_init_note_index,\n        b_init_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_2200_note,\n        b_additional_lend_amt,\n    ); \n\n    let b_2200_note_hash = hash_my_note(b_2200_note);\n    let b_2200_note_index = 4;\n    merkle_leaves[b_2200_note_index] = b_2200_note_hash;\n\n\n    // T = 32 hrs\n    // b borrow more, making will_liq_price rise to around 2400\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_2200_note_hash_path = [zero_leaf, merkle_tree[3], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    let b_2400_will_liq_price =  global_will_liq_price(2400, timestamp_32_hrs);\n    let b_2400_lend_amt = update_amt(b_2200_note.lend_amt, b_2200_note.timestamp, timestamp_32_hrs, LEND_INTEREST_RATE);\n    \n    let b_2400_borrow_amt = update_borrow_amt_new_liq_price(b_2400_will_liq_price, b_2400_lend_amt);\n    let b_updated_borrow_amt = update_amt(b_2200_note.borrow_amt, b_2200_note.timestamp, timestamp_32_hrs, BORROW_INTEREST_RATE );\n    let b_additional_borrow_amt = b_2400_borrow_amt - b_updated_borrow_amt;\n    \n\n    let b_2400_note = MyNote {\n        lend_amt: b_2400_lend_amt,\n        borrow_amt: b_2400_borrow_amt,\n        will_liq_price: b_2400_will_liq_price,\n        timestamp: timestamp_32_hrs,\n        nullifier: 1890 as Field,\n        nonce: 97 as Field,\n    };\n\n    borrow(\n        b_2200_note,\n        b_2200_note_hash,\n        b_2200_note_index,\n        b_2200_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_2400_note,\n        b_additional_borrow_amt,\n    ); \n\n    let b_2400_note_hash = hash_my_note(b_2400_note);\n    let b_2400_note_index = 5;\n    merkle_leaves[b_2400_note_index] = b_2400_note_hash;\n\n    // T = 72 hrs, liquidate 2600 ish..\n    let timestamp_72_hrs = 72* 60* 60;\n    liquidated_array[2] = Liquidated{liq_price: global_will_liq_price(2600, timestamp_72_hrs), timestamp: timestamp_72_hrs};\n    \n    // T = 96 hrs, b repays all his debt\n    let timestamp_96_hrs = 96* 60* 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_2400_note_hash_path = [merkle_leaves[4], merkle_tree[3], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    // repay all debt\n    let b_0_will_liq_price =  0;\n    let b_0_lend_amt = update_amt(b_2400_note.lend_amt, b_2400_note.timestamp, timestamp_96_hrs, LEND_INTEREST_RATE);\n    \n    let b_0_borrow_amt = 0;\n    let b_updated_borrow_amt = update_amt(b_2400_note.borrow_amt, b_2400_note.timestamp, timestamp_96_hrs, BORROW_INTEREST_RATE );\n    let b_repay_borrow_amt = b_updated_borrow_amt - b_0_borrow_amt;\n    \n\n    let b_0_note = MyNote {\n        lend_amt: b_0_lend_amt,\n        borrow_amt: b_0_borrow_amt,\n        will_liq_price: b_0_will_liq_price,\n        timestamp: timestamp_96_hrs,\n        nullifier: 2 as Field,\n        nonce: 932494 as Field,\n    };\n\n    repay(\n        b_2400_note,\n        b_2400_note_hash,\n        b_2400_note_index,\n        b_2400_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_0_note,\n        b_repay_borrow_amt,\n    ); \n\n    let b_0_note_hash = hash_my_note(b_0_note);\n    let b_0_note_index = 6;\n    merkle_leaves[b_0_note_index] = b_0_note_hash;\n\n    // T = 120 hrs, b withdraw some money\n    let timestamp_120_hrs = 120* 60* 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_0_note_hash_path = [zero_leaf, merkle_tree[2], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    let b_updated_lend_amt = update_amt(b_0_note.lend_amt, b_0_note.timestamp, timestamp_120_hrs, LEND_INTEREST_RATE);\n    let b_final_lend_amt = 20000;\n    let b_final_borrow_amt = 0;\n    let b_withdraw_lend_amt = b_updated_lend_amt - b_final_lend_amt;\n    \n\n    let b_final_note = MyNote {\n        lend_amt: b_final_lend_amt,\n        borrow_amt: b_final_borrow_amt,\n        will_liq_price: 0,\n        timestamp: timestamp_120_hrs,\n        nullifier: 223 as Field,\n        nonce: 12309 as Field,\n    };\n\n    withdraw(\n        b_0_note,\n        b_0_note_hash,\n        b_0_note_index,\n        b_0_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_final_note,\n        b_withdraw_lend_amt,\n    ); \n}\n\n\n#[test]\nfn test_inclusion_proof() {\n    let a = 1 as Field;\n    let b = 2 as Field;\n    let c = 3 as Field;\n    let d = 4 as Field;\n    let zero = 0 as Field;\n\n    let merkle_leaves = [a, b, c, d, zero, zero, zero, zero];\n    let merkle = construct_merkle_tree(merkle_leaves);\n    \n    let leaf = c;\n    let index = 2;\n    let hash_path = [d, merkle[0], merkle[5]];\n    let root = merkle[6];\n\n    assert_inclusion_proof(leaf, index, hash_path, root);\n}\n\n#[test]\nfn test_ltv() {\n    let my_note = MyNote {\n        lend_amt: 5,\n        borrow_amt: 10,\n        will_liq_price: 4,\n        timestamp: 1000,\n        nullifier: 111 as Field,\n        nonce: 222 as Field,\n    };\n    assert_ltv(my_note);\n}\n\n\n#[test]\nfn test_liquidation_check() {\n\n    let my_note = MyNote {\n        lend_amt: 1,\n        borrow_amt: 500,\n        will_liq_price: 1000,\n        timestamp: 1000,\n        nullifier: 111 as Field,\n        nonce: 222 as Field,\n    };\n\n    let liquidated_array = [\n        Liquidated { liq_price: 1100, timestamp: 1005 },   \n        Liquidated { liq_price: 1200, timestamp: 1010 },  \n        Liquidated { liq_price: 1100, timestamp: 1200 },  \n    ];\n    assert_ltv(my_note);\n    assert_non_liquidated(my_note, liquidated_array);\n}\n\n\n","path":"/Users/yoyoismacbook/Desktop/zk/zk-lending/circuits/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_invert","directive_integer_quotient"]}