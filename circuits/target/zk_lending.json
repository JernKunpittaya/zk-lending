{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17917208070025490196,"abi":{"parameters":[{"name":"new_note","type":{"kind":"struct","path":"MyNote","fields":[{"name":"lend_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"borrow_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"nullifier","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]},"visibility":"private"},{"name":"new_note_hash","type":{"kind":"field"},"visibility":"public"},{"name":"new_will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"new_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"prev_note","type":{"kind":"struct","path":"MyNote","fields":[{"name":"lend_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"borrow_amt","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"will_liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"nullifier","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]},"visibility":"private"},{"name":"prev_hash","type":{"kind":"field"},"visibility":"private"},{"name":"prev_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"prev_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"prev_hash_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"liquidated_array","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"Liquidated","fields":[{"name":"liq_price","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}}]}},"visibility":"public"},{"name":"lend_token_out","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"borrow_token_out","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"lend_token_in","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"borrow_token_in","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"/*\n * Zringotts Circuit - zk lending operation\n * This circuit is an all in one zk lending market state transition circuit.\n * Author: jernkun, yoyoismee, yoisha\n*/\n\nuse dep::std;\n\n// ==== Global config ==== (percentage-based)\nglobal LTV_THRESHOLD: u64 = 50; //\nglobal LEND_INTEREST_RATE: u64 = 3; // annual rate (3%)\nglobal BORROW_INTEREST_RATE: u64 = 10; // annual rate (10%)\nglobal ACCEPTABLE_PERCENT: u64 = 1;\n\n// Assume price is integer\nstruct Liquidated {\n    liq_price: u64, // in smallest unit as integer\n    timestamp: u64,\n}\n\nstruct MyNote {\n    lend_amt: u64, // in smallest unit (scaled, e.g., x10^4)\n    borrow_amt: u64, // in smallest unit (scaled, e.g., x10^4)\n    will_liq_price: u64, // in smallest unit as integer\n    timestamp: u64,\n    nullifier: Field,\n    nonce: Field,\n}\n\nfn simple_hash(left: Field, right: Field) -> Field {\n    std::hash::poseidon2::Poseidon2::hash([left, right], 2)\n}\n\nfn hash_my_note(my_note: MyNote) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(\n        [\n            my_note.lend_amt as Field,\n            my_note.borrow_amt as Field,\n            my_note.will_liq_price as Field,\n            my_note.timestamp as Field,\n            my_note.nullifier,\n            my_note.nonce,\n        ],\n        6,\n    )\n}\n\n// ====== CONSTRAINT ================\n// assert if LTV condition is satisfied\nfn assert_ltv(my_note: MyNote) {\n    assert(my_note.borrow_amt * 100 <= LTV_THRESHOLD * my_note.lend_amt * my_note.will_liq_price);\n}\n\nfn abs_diff(x: u64, y: u64) -> u64 {\n    if x >= y {\n        x - y\n    } else {\n        y - x\n    }\n}\n\n// Check if two values are within a percentage range\nfn is_within_percentage(x: u64, y: u64, percent: u64) -> u8 {\n    let diff = abs_diff(x, y) * 100;\n    let allowed_diff = percent * y;\n    if diff <= allowed_diff {\n        1\n    } else {\n        0\n    }\n}\n\n// Check if our will_liq_price is actually liquidated or not, accounting for lend & borrow interest\nfn is_myposition_liquidated(my_price: u64, liq_price: u64, my_time: u64, liq_time: u64) -> u8 {\n    if liq_time < my_time {\n        0\n    } else {\n        let one_year_seconds = 365 * 24 * 60 * 60;\n        let time_diff = liq_time - my_time;\n\n        let borrow_factor = one_year_seconds + BORROW_INTEREST_RATE * time_diff;\n        let lend_factor = one_year_seconds + LEND_INTEREST_RATE * time_diff;\n\n        let my_adjusted_price = borrow_factor * my_price;\n        let liq_adjusted_price = lend_factor * liq_price;\n\n        is_within_percentage(my_adjusted_price, liq_adjusted_price, ACCEPTABLE_PERCENT)\n    }\n}\n\nfn assert_update_amt(\n    prev_amt: u64,\n    prev_timestamp: u64,\n    curr_amt: u64,\n    curr_timestamp: u64,\n    interest_rate: u64,\n) {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = curr_timestamp - prev_timestamp;\n\n    let projected_amt = (one_year_seconds + interest_rate * time_diff) * prev_amt;\n    let actual_amt = one_year_seconds * curr_amt;\n\n    assert(is_within_percentage(projected_amt, actual_amt, ACCEPTABLE_PERCENT) == 1);\n}\n\n// check if my position is liquidated\nfn is_my_pos_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) -> u8 {\n    let mut is_liquidated: u8 = 0;\n\n    for i in 0..3 {\n        let check = is_myposition_liquidated(\n            my_note.will_liq_price,\n            liquidated_array[i].liq_price,\n            my_note.timestamp,\n            liquidated_array[i].timestamp,\n        );\n        is_liquidated += check;\n    }\n    if is_liquidated > 0 {\n        1\n    } else {\n        0\n    }\n}\n\n// assert that my position not liquidated\nfn assert_non_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) {\n    assert(is_my_pos_liquidated(my_note, liquidated_array) == 0);\n}\n\n// assert that my position gets liquidated\nfn assert_liquidated(my_note: MyNote, liquidated_array: [Liquidated; 3]) {\n    assert(is_my_pos_liquidated(my_note, liquidated_array) == 1);\n}\n\nfn process_path_hash(leaf: Field, index: u32, another_leaf: Field) -> Field {\n    // if index is even, then leaf is left child\n    // if index is odd, then leaf is right child\n    if index % 2 == 0 {\n        simple_hash(leaf, another_leaf)\n    } else {\n        simple_hash(another_leaf, leaf)\n    }\n}\n\nfn assert_inclusion_proof(leaf: Field, index: u32, hash_path: [Field; 3], root: Field) {\n    let mut calculated_hash = leaf;\n    let mut calculated_index = index;\n    for i in 0..3 {\n        calculated_hash = process_path_hash(calculated_hash, calculated_index, hash_path[i]);\n        calculated_index = calculated_index / 2;\n    }\n\n    assert(calculated_hash == root);\n}\n\n// ============ zk-lending OPERATION CONSTRAINT =============\n\n// if no borrow when initiating note, set borrow_amt = 0, and will_liq_price = 0\nfn init_note(\n    lend_amt: u64,\n    borrow_amt: u64,\n    will_liq_price: u64,\n    timestamp: u64,\n    nullifier: Field,\n    nonce: Field,\n) -> MyNote {\n    let my_note: MyNote =\n        MyNote { lend_amt, borrow_amt, will_liq_price, timestamp, nullifier, nonce };\n    assert_ltv(my_note);\n    my_note\n}\n\nfn borrow(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    additional_borrow_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    // assert updated lending amount\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    // assert updated borrowing amount (before borrowing more)\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt - additional_borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn repay(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    repay_borrow_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    // assert updated lending amount\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    assert(\n        repay_borrow_amt\n            <= update_amt(\n                prev_note.borrow_amt,\n                prev_note.timestamp,\n                new_note.timestamp,\n                BORROW_INTEREST_RATE,\n            ),\n    );\n\n    // assert updated borrowing amount (before borrowing more)\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt + repay_borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn lend(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    additional_deposit_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    // assert updated lending amount (before lending/depositing more)\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt - additional_deposit_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    // assert updated borrowing amount\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\nfn withdraw(\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_index: u32,\n    prev_hash_path: [Field; 3],\n    root: Field,\n    liquidated_array: [Liquidated; 3],\n    new_note: MyNote,\n    withdraw_lend_amt: u64,\n) -> Field {\n    assert(hash_my_note(prev_note) == prev_hash);\n    assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    assert_non_liquidated(prev_note, liquidated_array);\n\n    assert(\n        withdraw_lend_amt\n            <= update_amt(\n                prev_note.lend_amt,\n                prev_note.timestamp,\n                new_note.timestamp,\n                LEND_INTEREST_RATE,\n            ),\n    );\n\n    // assert updated lending amount (before lending/depositing more)\n    assert_update_amt(\n        prev_note.lend_amt,\n        prev_note.timestamp,\n        new_note.lend_amt + withdraw_lend_amt,\n        new_note.timestamp,\n        LEND_INTEREST_RATE,\n    );\n\n    // assert updated borrowing amount\n    assert_update_amt(\n        prev_note.borrow_amt,\n        prev_note.timestamp,\n        new_note.borrow_amt,\n        new_note.timestamp,\n        BORROW_INTEREST_RATE,\n    );\n\n    assert_ltv(new_note);\n    hash_my_note(new_note)\n}\n\n// =============== HELPER FUNCTIONS ========================\n\nfn construct_merkle_tree(leaf_array: [Field; 8]) -> [Field; 7] {\n    let mut lv1_nodes: [Field; 4] = [0; 4];\n    for i in 0..4 {\n        lv1_nodes[i] = simple_hash(leaf_array[2 * i], leaf_array[2 * i + 1]);\n    }\n    let mut lv2_nodes: [Field; 2] = [0; 2];\n    for i in 0..2 {\n        lv2_nodes[i] = simple_hash(lv1_nodes[2 * i], lv1_nodes[2 * i + 1]);\n    }\n    let root = simple_hash(lv2_nodes[0], lv2_nodes[1]);\n    [lv1_nodes[0], lv1_nodes[1], lv1_nodes[2], lv1_nodes[3], lv2_nodes[0], lv2_nodes[1], root]\n}\n\nfn update_amt(prev_amt: u64, prev_timestamp: u64, curr_timestamp: u64, interest_rate: u64) -> u64 {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = curr_timestamp - prev_timestamp;\n\n    (one_year_seconds + interest_rate * time_diff) * prev_amt / one_year_seconds\n}\n\nfn update_lend_amt_new_liq_price(will_liq_price: u64, borrow_amt: u64) -> u64 {\n    borrow_amt * 100 / (will_liq_price * LTV_THRESHOLD) + 1\n}\n\nfn update_borrow_amt_new_liq_price(will_liq_price: u64, lend_amt: u64) -> u64 {\n    will_liq_price * LTV_THRESHOLD * lend_amt / 100\n}\n\nfn global_will_liq_price(initial_will_liq_price: u64, timestamp: u64) -> u64 {\n    let one_year_seconds = 365 * 24 * 60 * 60;\n    let time_diff = timestamp - 0;\n\n    let borrow_factor = one_year_seconds + BORROW_INTEREST_RATE * time_diff;\n    let lend_factor = one_year_seconds + LEND_INTEREST_RATE * time_diff;\n\n    borrow_factor * initial_will_liq_price / lend_factor\n}\n\n// Zringotts Circuit - all in one zk banking operation \n// the name have nothing to do with goblins, wizzard, or british writers. (don't sue us)\n// 1. init note - if old is empty init note with no check\n// 2. if liquidated, force sell all assets and credit it as borrow asset\n// 3. lend, borrow, repay, withdraw - attempt to update the note and check aginst constraints\nfn main(\n    new_note: MyNote,\n    new_note_hash: pub Field,\n    new_will_liq_price: pub u64,\n    new_timestamp: pub u64,\n    prev_note: MyNote,\n    prev_hash: Field,\n    prev_nullifier: Field,\n    prev_index: u32,\n    prev_hash_path: pub [Field; 3],\n    root: pub Field,\n    liquidated_array: pub [Liquidated; 3],\n    lend_token_out: pub u64,\n    borrow_token_out: pub u64,\n    lend_token_in: pub u64,\n    borrow_token_in: pub u64,\n) {\n    // return the new note hash\n    assert(new_will_liq_price == new_note.will_liq_price);\n\n    // assert that token in and out are mutually exclusive\n    assert(lend_token_in * lend_token_out == 0);\n    assert(borrow_token_in * borrow_token_out == 0);\n\n    // if old is empty no inclusion proof needed.\n    // note: lend_amt, borrow_amt, will_liq_price = 0 mean empty note\n    if (prev_note.lend_amt + prev_note.borrow_amt + prev_note.will_liq_price) > 0 {\n        // validate the old note\n        assert(prev_nullifier == prev_note.nullifier);\n        assert(hash_my_note(prev_note) == prev_hash);\n        assert_inclusion_proof(prev_hash, prev_index, prev_hash_path, root);\n    }\n\n    // if the old note is liquidated, settle the note\n    if is_my_pos_liquidated(prev_note, liquidated_array) == 1 {\n        // calculate asset left after liquidation. interest is forfeited in this case.\n        // give asset back to the user and reset the note\n        assert_liquidated(prev_note, liquidated_array);\n        let lend_asset_left_eqv = prev_note.lend_amt * prev_note.will_liq_price;\n        let borrow_amt = update_amt(\n            prev_note.borrow_amt,\n            prev_note.timestamp,\n            new_timestamp,\n            BORROW_INTEREST_RATE,\n        );\n        let borrow_asset_left_eqv = lend_asset_left_eqv - borrow_amt;\n        assert(borrow_token_out <= borrow_asset_left_eqv);\n        assert(borrow_token_in == 0);\n        assert(lend_token_out == 0);\n        assert(lend_token_in == 0);\n\n        assert(new_note.lend_amt == 0);\n        assert(new_note.borrow_amt == 0);\n        assert(new_note.will_liq_price == 0);\n        assert(new_note.timestamp == new_timestamp);\n\n        assert(new_note_hash == hash_my_note(new_note)); // create new empty note\n    } else {\n        // assert that the old note is not liquidated\n        assert_non_liquidated(prev_note, liquidated_array);\n\n        let new_lend_amt = update_amt(\n            prev_note.lend_amt,\n            prev_note.timestamp,\n            new_timestamp,\n            LEND_INTEREST_RATE,\n        )\n            + lend_token_in\n            - lend_token_out;\n\n        assert(new_lend_amt >= new_note.lend_amt);   // check for note allow for same or lower lend_amt\n\n        let new_borrow_amt = update_amt(\n            prev_note.borrow_amt,\n            prev_note.timestamp,\n            new_timestamp,\n            BORROW_INTEREST_RATE,\n        )\n            + borrow_token_in\n            - borrow_token_out;\n        assert(new_borrow_amt <= new_note.borrow_amt); // check for note allow for same or more borrow_amt\n\n\n        assert_ltv(new_note);\n        // assert that the new note is not liquidated\n        assert_non_liquidated(new_note, liquidated_array);\n        assert(new_note_hash == hash_my_note(new_note));\n    }\n    // return 0 as placeholder\n}\n\n#[test]\nfn test_main_real(){\n\n\n    // create empty tree\n    let zero_leaf = 0 as Field;\n    let mut merkle_leaves: [Field; 8] = (\n        [\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n        ]\n    );\n    let mut merkle_tree = construct_merkle_tree(merkle_leaves);\n    let mut merkle_root = merkle_tree[6];\n    let mut liquidated_array: [Liquidated; 3] = [\n        Liquidated { liq_price: 1500, timestamp: 0 },\n        Liquidated { liq_price: 1600, timestamp: 0 },\n        Liquidated { liq_price: 1700, timestamp: 0 },\n    ];\n\n    // a, b deposit and borrow right away\n    let a_init_lend_amt = 500; // already scale by (10^4)\n    let a_init_will_liq_price = 2800;\n    let timestamp_0 = 123;\n    let a_init_borrow_amt = 1500;\n    let empty_note = MyNote {\n        lend_amt: 0,\n        borrow_amt: 0,\n        will_liq_price: 0,\n        timestamp: 0,\n        nullifier: 0 as Field,\n        nonce: 0 as Field,\n    };\n    let expected_new_note = MyNote {\n        lend_amt: a_init_lend_amt,\n        borrow_amt: a_init_borrow_amt,\n        will_liq_price: a_init_will_liq_price,\n        timestamp: timestamp_0,\n        nullifier: 112 as Field,\n        nonce: 13 as Field,\n    };\n    let expected_new_note_hash = hash_my_note(expected_new_note);\n    main(\n        expected_new_note,\n        expected_new_note_hash,\n        a_init_will_liq_price,\n        timestamp_0,\n        empty_note,\n        zero_leaf,\n        zero_leaf,\n        0,\n        [zero_leaf, zero_leaf, zero_leaf],\n        merkle_root,\n        liquidated_array,\n        0,\n        0,\n        a_init_lend_amt,\n        a_init_borrow_amt,\n    );\n\n    // test borrow\n    let last_note_hash = expected_new_note_hash;\n    let last_note_index = 0;\n    let merkle_leaves = [\n        last_note_hash,\n        zero_leaf,\n        zero_leaf,\n        zero_leaf,\n        zero_leaf,\n        zero_leaf,\n        zero_leaf,\n        zero_leaf,\n    ];\n    merkle_tree = construct_merkle_tree(merkle_leaves);\n    merkle_root = merkle_tree[6];\n    let last_note_hash_path = [zero_leaf, merkle_tree[1], merkle_tree[5]];\n    \n\n    let last_note = expected_new_note;\n\n    let to_borrow_amt = 500;\n    let expected_new_borrow_amt = a_init_borrow_amt + to_borrow_amt;\n    let expected_new_note = MyNote {\n        lend_amt: a_init_lend_amt,\n        borrow_amt: expected_new_borrow_amt,\n        will_liq_price: a_init_will_liq_price,\n        timestamp: timestamp_0,\n        nullifier: 114 as Field,\n        nonce: 19 as Field,\n    };\n    let expected_new_note_hash = hash_my_note(expected_new_note);\n    let old_expected_new_note_hash_path = [zero_leaf, merkle_tree[1], merkle_tree[5]];\n    \n    assert_inclusion_proof(last_note_hash, 0, old_expected_new_note_hash_path, merkle_root);\n\n    main(\n        expected_new_note,\n        expected_new_note_hash,\n        a_init_will_liq_price,\n        timestamp_0,\n        last_note,\n        last_note_hash,\n        last_note.nullifier,\n        0,\n        old_expected_new_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        0,\n        to_borrow_amt,\n        0,\n        0,\n    );\n\n\n\n    \n\n\n}\n\n#[test]\nfn test_main() {\n    // Time = 0, current ETH price = 3000,\n    // there exists buckets at liquidation price 2800, 2600, 2400, 2200\n \n\n    let zero_leaf = 0 as Field;\n    let mut merkle_leaves: [Field; 8] = (\n        [\n            1234 as Field,\n            542 as Field,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n            zero_leaf,\n        ]\n    );\n    let mut liquidated_array: [Liquidated; 3] = [\n        Liquidated { liq_price: 0, timestamp: 0 },\n        Liquidated { liq_price: 0, timestamp: 0 },\n        Liquidated { liq_price: 0, timestamp: 0 },\n    ];\n    // a, b deposit and borrow right away\n    let a_init_lend_amt = 50000; // already scale by (10^4)\n    let a_init_will_liq_price = 2800;\n    let a_init_borrow_amt = update_borrow_amt_new_liq_price(a_init_will_liq_price, a_init_lend_amt);\n    let a_init_note = init_note(\n        a_init_lend_amt,\n        a_init_borrow_amt,\n        a_init_will_liq_price,\n        0,\n        112 as Field,\n        13 as Field,\n    );\n\n    let b_init_lend_amt = 20000; // already scale by (10^4)\n    let b_init_will_liq_price = 2600;\n    let b_init_borrow_amt = update_borrow_amt_new_liq_price(b_init_will_liq_price, b_init_lend_amt);\n    let b_init_note = init_note(\n        b_init_lend_amt,\n        b_init_borrow_amt,\n        b_init_will_liq_price,\n        0,\n        132 as Field,\n        156 as Field,\n    );\n\n    let a_init_note_hash = hash_my_note(a_init_note);\n    let a_init_note_index = 2;\n    merkle_leaves[a_init_note_index] = a_init_note_hash;\n    let b_init_note_hash = hash_my_note(b_init_note);\n    let b_init_note_index = 3;\n    merkle_leaves[b_init_note_index] = b_init_note_hash;\n\n    // T = 4 hrs, liquidate 2800 ish, then bounce back 2900\n    let timestamp_4_hrs = 4 * 60 * 60;\n    liquidated_array[0] = Liquidated {\n        liq_price: global_will_liq_price(2800, timestamp_4_hrs),\n        timestamp: timestamp_4_hrs,\n    };\n\n    // T = 12 hrs, liquidate 2800 ish again (since someone initiate position in this bucket)\n    let timestamp_12_hrs = 12 * 60 * 60;\n    liquidated_array[1] = Liquidated {\n        liq_price: global_will_liq_price(2800, timestamp_12_hrs),\n        timestamp: timestamp_12_hrs,\n    };\n\n    // a's position is gone\n    assert_liquidated(a_init_note, liquidated_array);\n\n    // T = 32 hrs\n    // b lend more, making will_liq_price drop to around 2200\n    let timestamp_32_hrs = 32 * 60 * 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_init_note_hash_path = [merkle_leaves[2], merkle_tree[0], merkle_tree[5]];\n    let merkle_root = merkle_tree[6];\n\n    let b_2200_will_liq_price = global_will_liq_price(2200, timestamp_32_hrs);\n    let b_2200_borrow_amt = update_amt(\n        b_init_note.borrow_amt,\n        b_init_note.timestamp,\n        timestamp_32_hrs,\n        BORROW_INTEREST_RATE,\n    );\n\n    let b_2200_lend_amt = update_lend_amt_new_liq_price(b_2200_will_liq_price, b_2200_borrow_amt);\n    let b_updated_lend_amt = update_amt(\n        b_init_note.lend_amt,\n        b_init_note.timestamp,\n        timestamp_32_hrs,\n        LEND_INTEREST_RATE,\n    );\n    let b_additional_lend_amt = b_2200_lend_amt - b_updated_lend_amt;\n\n    let b_2200_note = MyNote {\n        lend_amt: b_2200_lend_amt,\n        borrow_amt: b_2200_borrow_amt,\n        will_liq_price: b_2200_will_liq_price,\n        timestamp: timestamp_32_hrs,\n        nullifier: 999 as Field,\n        nonce: 888 as Field,\n    };\n\n    lend(\n        b_init_note,\n        b_init_note_hash,\n        b_init_note_index,\n        b_init_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_2200_note,\n        b_additional_lend_amt,\n    );\n\n    let b_2200_note_hash = hash_my_note(b_2200_note);\n    let b_2200_note_index = 4;\n    merkle_leaves[b_2200_note_index] = b_2200_note_hash;\n\n    // T = 32 hrs\n    // b borrow more, making will_liq_price rise to around 2400\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_2200_note_hash_path = [zero_leaf, merkle_tree[3], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    let b_2400_will_liq_price = global_will_liq_price(2400, timestamp_32_hrs);\n    let b_2400_lend_amt = update_amt(\n        b_2200_note.lend_amt,\n        b_2200_note.timestamp,\n        timestamp_32_hrs,\n        LEND_INTEREST_RATE,\n    );\n\n    let b_2400_borrow_amt = update_borrow_amt_new_liq_price(b_2400_will_liq_price, b_2400_lend_amt);\n    let b_updated_borrow_amt = update_amt(\n        b_2200_note.borrow_amt,\n        b_2200_note.timestamp,\n        timestamp_32_hrs,\n        BORROW_INTEREST_RATE,\n    );\n    let b_additional_borrow_amt = b_2400_borrow_amt - b_updated_borrow_amt;\n\n    let b_2400_note = MyNote {\n        lend_amt: b_2400_lend_amt,\n        borrow_amt: b_2400_borrow_amt,\n        will_liq_price: b_2400_will_liq_price,\n        timestamp: timestamp_32_hrs,\n        nullifier: 1890 as Field,\n        nonce: 97 as Field,\n    };\n\n    borrow(\n        b_2200_note,\n        b_2200_note_hash,\n        b_2200_note_index,\n        b_2200_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_2400_note,\n        b_additional_borrow_amt,\n    );\n\n    let b_2400_note_hash = hash_my_note(b_2400_note);\n    let b_2400_note_index = 5;\n    merkle_leaves[b_2400_note_index] = b_2400_note_hash;\n\n    // T = 72 hrs, liquidate 2600 ish..\n    let timestamp_72_hrs = 72 * 60 * 60;\n    liquidated_array[2] = Liquidated {\n        liq_price: global_will_liq_price(2600, timestamp_72_hrs),\n        timestamp: timestamp_72_hrs,\n    };\n\n    // T = 96 hrs, b repays all his debt\n    let timestamp_96_hrs = 96 * 60 * 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_2400_note_hash_path = [merkle_leaves[4], merkle_tree[3], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    // repay all debt\n    let b_0_will_liq_price = 0;\n    let b_0_lend_amt = update_amt(\n        b_2400_note.lend_amt,\n        b_2400_note.timestamp,\n        timestamp_96_hrs,\n        LEND_INTEREST_RATE,\n    );\n\n    let b_0_borrow_amt = 0;\n    let b_updated_borrow_amt = update_amt(\n        b_2400_note.borrow_amt,\n        b_2400_note.timestamp,\n        timestamp_96_hrs,\n        BORROW_INTEREST_RATE,\n    );\n    let b_repay_borrow_amt = b_updated_borrow_amt - b_0_borrow_amt;\n\n    let b_0_note = MyNote {\n        lend_amt: b_0_lend_amt,\n        borrow_amt: b_0_borrow_amt,\n        will_liq_price: b_0_will_liq_price,\n        timestamp: timestamp_96_hrs,\n        nullifier: 2 as Field,\n        nonce: 932494 as Field,\n    };\n\n    repay(\n        b_2400_note,\n        b_2400_note_hash,\n        b_2400_note_index,\n        b_2400_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_0_note,\n        b_repay_borrow_amt,\n    );\n\n    let b_0_note_hash = hash_my_note(b_0_note);\n    let b_0_note_index = 6;\n    merkle_leaves[b_0_note_index] = b_0_note_hash;\n\n    // T = 120 hrs, b withdraw some money\n    let timestamp_120_hrs = 120 * 60 * 60;\n    let merkle_tree = construct_merkle_tree(merkle_leaves);\n    let b_0_note_hash_path = [zero_leaf, merkle_tree[2], merkle_tree[4]];\n    let merkle_root = merkle_tree[6];\n\n    let b_updated_lend_amt = update_amt(\n        b_0_note.lend_amt,\n        b_0_note.timestamp,\n        timestamp_120_hrs,\n        LEND_INTEREST_RATE,\n    );\n    let b_final_lend_amt = 20000;\n    let b_final_borrow_amt = 0;\n    let b_withdraw_lend_amt = b_updated_lend_amt - b_final_lend_amt;\n\n    let b_final_note = MyNote {\n        lend_amt: b_final_lend_amt,\n        borrow_amt: b_final_borrow_amt,\n        will_liq_price: 0,\n        timestamp: timestamp_120_hrs,\n        nullifier: 223 as Field,\n        nonce: 12309 as Field,\n    };\n\n    withdraw(\n        b_0_note,\n        b_0_note_hash,\n        b_0_note_index,\n        b_0_note_hash_path,\n        merkle_root,\n        liquidated_array,\n        b_final_note,\n        b_withdraw_lend_amt,\n    );\n}\n\n#[test]\nfn test_inclusion_proof() {\n    let a = 1 as Field;\n    let b = 2 as Field;\n    let c = 3 as Field;\n    let d = 4 as Field;\n    let zero = 0 as Field;\n\n    let merkle_leaves = [a, b, c, d, zero, zero, zero, zero];\n    let merkle = construct_merkle_tree(merkle_leaves);\n\n    let leaf = c;\n    let index = 2;\n    let hash_path = [d, merkle[0], merkle[5]];\n    let root = merkle[6];\n\n    assert_inclusion_proof(leaf, index, hash_path, root);\n}\n\n#[test]\nfn test_ltv() {\n    let my_note = MyNote {\n        lend_amt: 5,\n        borrow_amt: 10,\n        will_liq_price: 4,\n        timestamp: 1000,\n        nullifier: 111 as Field,\n        nonce: 222 as Field,\n    };\n    assert_ltv(my_note);\n}\n\n#[test]\nfn test_liquidation_check() {\n    let my_note = MyNote {\n        lend_amt: 1,\n        borrow_amt: 500,\n        will_liq_price: 1000,\n        timestamp: 1000,\n        nullifier: 111 as Field,\n        nonce: 222 as Field,\n    };\n\n    let liquidated_array = [\n        Liquidated { liq_price: 1100, timestamp: 1005 },\n        Liquidated { liq_price: 1200, timestamp: 1010 },\n        Liquidated { liq_price: 1100, timestamp: 1200 },\n    ];\n    assert_ltv(my_note);\n    assert_non_liquidated(my_note, liquidated_array);\n}\n","path":"/Users/yoisha/Development/crypto/zk-lending/circuits/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}